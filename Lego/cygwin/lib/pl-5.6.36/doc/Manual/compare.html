<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.35 Reference Manual: Section 4.6</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="typetest.html">
<LINK REL=next HREF="control.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text: { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="typetest.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="control.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:4.6"><SPAN class="sec-nr">4.6</SPAN> <SPAN class="sec-title">Comparison 
and Unification or Terms</SPAN></A></H2>

<A NAME="sec:compare"></A>

<H3><A NAME="sec:4.6.1"><SPAN class="sec-nr">4.6.1</SPAN> <SPAN class="sec-title">Standard 
Order of Terms</SPAN></A></H3>

<A NAME="sec:standardorder"></A>

<P>Comparison and unification of arbitrary terms. Terms are ordered in 
the so called ``standard order''. This order is defined as follows:

<P><OL>
<LI><VAR><VAR>Variables</VAR> &lt; <VAR>Numbers</VAR> &lt; <VAR>Atoms</VAR> 
&lt; <VAR>Strings</VAR> &lt; <VAR>Comound Terms</VAR></VAR><SUP class="fn">25<SPAN class="fn-text">Strings 
might be considered atoms in future versions. See also <A class="sec" href="strings.html">section 
4.23</A></SPAN></SUP>
<LI>Variables are sorted by address. Attaching attributes (see <A class="sec" href="attvar.html">section 
6.1</A>) does not affect the ordering.
<LI><VAR>Atoms</VAR> are compared alphabetically.
<LI><VAR>Strings</VAR> are compared alphabetically.
<LI><VAR>Numbers</VAR> are compared by value. Integers and floats are 
treated identically. If the prolog_flag (see <A NAME="idx:currentprologflag2:451"></A><A class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</A>)
<CODE>iso</CODE> is defined, all floating point numbers precede all 
integers.
<LI><VAR>Compound</VAR> terms are first checked on their arity, then on 
their functor-name (alphabetically) and finally recursively on their 
arguments, leftmost argument first.
</OL>

<DL>
<DT class="pubdef"><A NAME="==/2"><VAR>+Term1</VAR> <STRONG>==</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
True if <VAR>Term1</VAR> is equivalent to <VAR>Term2</VAR>. A variable 
is only identical to a sharing variable.
</DD>
<DT class="pubdef"><A NAME="\==/2"><VAR>+Term1</VAR> <STRONG>\==</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
Equivalent to <CODE><CODE>\+</CODE>Term1 == Term2</CODE>.
</DD>
<DT class="pubdef"><A NAME="=/2"><VAR>+Term1</VAR> <STRONG>=</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
Unify <VAR>Term1</VAR> with <VAR>Term2</VAR>. True if the unification 
succeeds.
</DD>
<DT class="pubdef"><A NAME="unify_with_occurs_check/2"><STRONG>unify_with_occurs_check</STRONG>(<VAR>+Term1, 
+Term2</VAR>)</A></DT>
<DD class="defbody">
As <A class="pred" href="compare.html#=/2">=/2</A>, but using <EM>sound-unification</EM>. 
That is, a variable only unifies to a term if this term does not contain 
the variable itself. To illustrate this, consider the two goals below:

<PRE class="code">
1 ?- A = f(A).

A = f(f(f(f(f(f(f(f(f(f(...))))))))))
2 ?- unify_with_occurs_check(A, f(A)).

No
</PRE>

<P>I.e. the first creates a <EM>cyclic-term</EM>, which is printed as an 
infinitely nested f/1 term (see the <CODE>max_depth</CODE> option of <A NAME="idx:writeterm2:452"></A><A class="pred" href="termrw.html#write_term/2">write_term/2</A>). 
The second executes logically sound unification and thus fails.</DD>
<DT class="pubdef"><A NAME="\=/2"><VAR>+Term1</VAR> <STRONG>\=</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
Equivalent to <CODE><CODE>\+</CODE>Term1 = Term2</CODE>.</DD>
<DT class="pubdef"><A NAME="=@=/2"><VAR>+Term1</VAR> <STRONG>=@=</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
True if <VAR>Term1</VAR> is `structurally equal' to <VAR>Term2</VAR>. 
Structural equivalence is weaker than equivalence (<A class="pred" href="compare.html#==/2">==/2</A>), 
but stronger than unification (<A class="pred" href="compare.html#=/2">=/2</A>). 
Two terms are structurally equal if their tree representation is 
identical and they have the same `pattern' of variables. Examples:
<BLOCKQUOTE>
<TABLE BORDER=0 FRAME=void RULES=groups>
<TR VALIGN=top><TD ALIGN=right><TT>a</TT></TD><TD ALIGN=center><TT>=@=</TT></TD><TD><TT>A</TT></TD><TD ALIGN=center>false </TD></TR>
<TR VALIGN=top><TD ALIGN=right><TT>A</TT></TD><TD ALIGN=center><TT>=@=</TT></TD><TD><TT>B</TT></TD><TD ALIGN=center>true </TD></TR>
<TR VALIGN=top><TD ALIGN=right><TT>x(A,A)</TT></TD><TD ALIGN=center><TT>=@=</TT></TD><TD><TT>x(B,C)</TT></TD><TD ALIGN=center>false </TD></TR>
<TR VALIGN=top><TD ALIGN=right><TT>x(A,A)</TT></TD><TD ALIGN=center><TT>=@=</TT></TD><TD><TT>x(B,B)</TT></TD><TD ALIGN=center>true </TD></TR>
<TR VALIGN=top><TD ALIGN=right><TT>x(A,B)</TT></TD><TD ALIGN=center><TT>=@=</TT></TD><TD><TT>x(C,D)</TT></TD><TD ALIGN=center>true </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>The predicates <A class="pred" href="compare.html#=@=/2">=@=/2</A> 
and <A class="pred" href="compare.html#\=@=/2">\=@=/2</A> are 
cycle-safe. Attributed variables are considered structurally equal iff 
their attributes are structurally equal.</DD>
<DT class="pubdef"><A NAME="\=@=/2"><VAR>+Term1</VAR> <STRONG>\=@=</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
Equivalent to <CODE>`<CODE>\+</CODE>Term1 =@= Term2'</CODE>.</DD>
<DT class="pubdef"><A NAME="@</2"><VAR>+Term1</VAR> <STRONG>@&lt;</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
True if <VAR>Term1</VAR> is before <VAR>Term2</VAR> in the standard 
order of terms.</DD>
<DT class="pubdef"><A NAME="@=</2"><VAR>+Term1</VAR> <STRONG>@=&lt;</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
True if both terms are equal (<A class="pred" href="compare.html#==/2">==/2</A>) 
or <VAR>Term1</VAR> is before <VAR>Term2</VAR> in the standard order of 
terms.</DD>
<DT class="pubdef"><A NAME="@>/2"><VAR>+Term1</VAR> <STRONG>@&gt;</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
True if <VAR>Term1</VAR> is after <VAR>Term2</VAR> in the standard order 
of terms.</DD>
<DT class="pubdef"><A NAME="@>=/2"><VAR>+Term1</VAR> <STRONG>@&gt;=</STRONG> <VAR>+Term2</VAR></A></DT>
<DD class="defbody">
True if both terms are equal (<A class="pred" href="compare.html#==/2">==/2</A>) 
or <VAR>Term1</VAR> is after <VAR>Term2</VAR> in the standard order of 
terms.</DD>
<DT class="pubdef"><A NAME="compare/3"><STRONG>compare</STRONG>(<VAR>?Order, 
+Term1, +Term2</VAR>)</A></DT>
<DD class="defbody">
Determine or test the <VAR>Order</VAR> between two terms in the standard 
order of terms. <VAR>Order</VAR> is one of <CODE><CODE>&lt;</CODE></CODE>, <CODE><CODE>&gt;</CODE></CODE> 
or <CODE><CODE>=</CODE></CODE>, with the obvious meaning.</DD>
<DT class="pubdef"><A NAME="?=/2"><STRONG>?=</STRONG>(<VAR>@Term1, @Term2</VAR>)</A></DT>
<DD class="defbody">
Decide whether the equality of <VAR>Term1</VAR> and <VAR>Term2</VAR> can 
be compared safely, i.e. whether the result of <CODE>Term1 == Term2</CODE> 
can change due to further instantiation of either term. It is defined as 
by <CODE>?=(A,B) :- (A==B ; A \= B), !.</CODE> See also
<A NAME="idx:dif2:453"></A><A class="pred" href="coroutining.html#dif/2">dif/2</A>.</DD>
<DT class="pubdef"><A NAME="unifiable/3"><STRONG>unifiable</STRONG>(<VAR>@X, @Y, 
-Unifier</VAR>)</A></DT>
<DD class="defbody">
If <VAR>X</VAR> and <VAR>Y</VAR> can unify, unify <VAR>Unifier</VAR> 
with a list of
<VAR>Var</VAR> = <VAR>Value</VAR>, representing the bindings required to 
make <VAR>X</VAR> and <VAR>Y</VAR> equivalent.<SUP class="fn">26<SPAN class="fn-text">This 
predicate was introduced for the implementation of <A NAME="idx:dif2:454"></A><A class="pred" href="coroutining.html#dif/2">dif/2</A> 
and <A NAME="idx:when2:455"></A><A class="pred" href="coroutining.html#when/2">when/2</A> 
after discussion with Tom Schrijvers and Bart Demoen. None of us is 
really happy with the name and therefore suggestions for a new name are 
welcome.</SPAN></SUP> This predicate can handle cyclic terms. Attributed 
variables are handles as normal variables. Associated hooks are <EM>not</EM> 
executed.
</DD>
</DL>

<P></BODY></HTML>